options {
  STATIC = false;
}

PARSER_BEGIN(RusskiyCompiler)
import java.io.*;

public class RusskiyCompiler {
    public static void main(String args[]) throws ParseException {
      RusskiyCompiler parser = new RusskiyCompiler(System.in);
      
      while (true) {
        System.out.println("------------------------------------------------");
        System.out.println("Nachalo - Compilador Russo (Digite ou CTRL+C para sair):");
        System.out.print("> ");
        
        try {
            parser.Programa();
            System.out.println("✔ Código aceito (Slava Russkiy)!");
        } catch (ParseException e) {
            System.out.println("❌ Erro sintático:");
            System.out.println(e.getMessage());
            parser.ReInit(System.in);
        } catch (TokenMgrError e) {
            System.out.println("❌ Erro léxico:");
            System.out.println(e.getMessage());
            parser.ReInit(System.in);
        }
      }
    }
}
PARSER_END(RusskiyCompiler)

// ==========================================
// CÓDIGO JAVACC (RECUPERAÇÃO DE ERRO)
// ==========================================

JAVACODE
void error_skipto(int kind) {
  ParseException e = generateParseException();
  System.out.println(e.getMessage());
  Token t;
  do {
    t = getNextToken();
  } while (t.kind != kind && t.kind != EOF);
}

// ==========================================
// TOKENS E REGRAS
// ==========================================

SKIP : {
    " " | "\t" | "\n" | "\r" | "\u00a0"
}

// --- Comentários ---
MORE : {
    "ili" : IN_SINGLE_LINE_COMMENT
}
<IN_SINGLE_LINE_COMMENT> SKIP : {
    < ~["\n","\r"] >
}
<IN_SINGLE_LINE_COMMENT> SKIP : {
    < ("\n"|"\r"|"\r\n") > : DEFAULT
}

// =============================
// Tokens
// =============================
TOKEN : {
  // --- Palavras-Chave ---
    < VOID      : "pusto"                > 
  | < INT       : "tseloye"              > 
  | < FLOAT     : "drobnoye"             > 
  | < STRING    : "slova"                > 
  | < IF        : "yesli"                > 
  | < ELSE      : "inache"               > 
  | < FOR       : "kazhday"              > 
  | < WHILE     : "poka"                 > 
  | < PRINT     : "vyvod"                > 
  | < INPUT     : "vvod"                 > 

  // --- Operadores Compostos ---
  | < EQ        : "=="                   > 
  | < NEQ       : "!="                   > 
  | < LE        : "<="                   > 
  | < GE        : ">="                   > 
  | < INC       : "++"                   > 
  | < DEC       : "--"                   > 
  | < POW       : "**"                   > 
  | < DIVINT    : "//"                   > 

  // --- Operadores Simples ---
  | < ASSIGN    : "="                    > 
  | < GT        : ">"                    > 
  | < LT        : "<"                    > 
  | < PLUS      : "+"                    > 
  | < MINUS     : "-"                    > 
  | < MULT      : "*"                    > 
  | < DIV       : "/"                    > 
  | < MOD       : "%"                    > 

  // --- Pontuação ---
  | < LPAREN    : "("                    > 
  | < RPAREN    : ")"                    > 
  | < LBRACE    : "{"                    > 
  | < RBRACE    : "}"                    > 
  | < SEMICOLON : ";"                    > 
  | < COMMA     : ","                    > 
  | < DOT       : "."                    > 

  // --- Literais ---
  | < IDENTIFIER : ["a"-"z","A"-"Z","_"] ( ["a"-"z","A"-"Z","0"-"9","_"] )* >
  | < NUMBER     : (["0"-"9"])+ ( "." (["0"-"9"])+ )? >
  | < STRING_LITERAL : "\"" (~["\"","\n","\r"])* "\"" >
}

// =============================
// Gramática com AST e Pânico
// =============================

void Programa() : { No raiz = new No("PROGRAMA"); No filho; }
{
    ( 
      filho = Comando() 
      { if (filho != null) raiz.addFilho(filho); } 
    )* <EOF>

    { 
        System.out.println("\n=== ARVORE SINTATICA ===\n");
        raiz.imprimirRaiz(); 
    }
}

No Comando() : { No n = null; }
{
    (
      n = Condicional() 
    | n = Iteracao()
    | n = IO()
    | n = Declaracao()
    | n = FraseFinalizada()
    )
    { return n; }
}

No IO() : { No n = new No("IO"); No expr; Token t; }
{
    <PRINT> <LPAREN> expr = Expressao() <RPAREN> <SEMICOLON>
    { 
        n.addFilho(new No("Comando", "vyvod"));
        n.addFilho(expr);
        return n; 
    }
    |
    <INPUT> <LPAREN> t=<IDENTIFIER> <RPAREN> <SEMICOLON>
    { 
        n.addFilho(new No("Comando", "vvod"));
        n.addFilho(new No("Var", t.image));
        return n; 
    }
}

// --- MODO PÂNICO ---
No FraseFinalizada() : { No n = null; }
{
    try {
        n = Frase() <SEMICOLON>
        { return n; }
    }
    catch (ParseException e) {
        error_skipto(SEMICOLON);
        return new No("[ERRO DE SINTAXE]"); 
    }
}

No Frase() : { No expr; No n = new No("Frase"); No atrib; }
{
    expr = Expressao() 
    (
        // Atribuição
        <ASSIGN> atrib = Expressao()
        { 
             n = new No("Atribuicao");
             n.addFilho(expr); 
             n.addFilho(new No("Operador", "="));
             n.addFilho(atrib); 
             return n;
        }
      | 
        // Incremento
        <INC>
        {
             n = new No("Incremento");
             n.addFilho(expr);
             return n;
        }
      | 
        // Decremento
        <DEC>
        {
             n = new No("Decremento");
             n.addFilho(expr);
             return n;
        }
    )?
    
    { return expr; }
}

No Declaracao() : { No n = new No("Declaracao"); No tipo; Token t; No inic = null; }
{
    tipo = TipoEspecificador() t=<IDENTIFIER> inic = OpcionalInicializacao() <SEMICOLON>
    {
        n.addFilho(tipo);
        n.addFilho(new No("Var", t.image));
        if (inic != null) {
            n.addFilho(new No("Inicializacao"));
            n.addFilho(inic);
        }
        return n;
    }
}

No OpcionalInicializacao() : { No expr = null; }
{
    [ <ASSIGN> expr = Expressao() ]
    { return expr; }
}

No TipoEspecificador() : { Token t; }
{
    ( t=<VOID> | t=<INT> | t=<FLOAT> | t=<STRING> )
    { return new No("Tipo", t.image); }
}

No Condicional() : { 
    No n = new No("IF"); 
    No cond; 
    No cmd; 
    No blocoIf = new No("Bloco True");
    No blocoElse = null;
}
{
    <IF> <LPAREN> cond=Expressao() <RPAREN> <LBRACE> 
    { 
        n.addFilho(cond); 
    }
    ( cmd=Comando() { blocoIf.addFilho(cmd); } )* <RBRACE>
    { n.addFilho(blocoIf); }
    
    [ 
      <ELSE> <LBRACE> 
      { blocoElse = new No("Bloco Else"); }
      ( cmd=Comando() { blocoElse.addFilho(cmd); } )* <RBRACE> 
      { n.addFilho(blocoElse); }
    ]
    
    { return n; }
}

No Iteracao() : { 
    No n = new No("WHILE"); 
    No cond; 
    No cmd; 
    No bloco = new No("Bloco Loop");
}
{
    <WHILE> <LPAREN> cond=Expressao() <RPAREN> <LBRACE>
    { n.addFilho(cond); }
    ( cmd=Comando() { bloco.addFilho(cmd); } )* <RBRACE>
    { 
        n.addFilho(bloco); 
        return n; 
    }
}

No Expressao() : { No n; } 
{
    n = ExpressaoRelacional() { return n; }
}

No ExpressaoRelacional() : { No atual, prox; Token op; }
{
    atual = ExpressaoAditiva() 
    ( 
      ( op=<EQ> | op=<NEQ> | op=<GT> | op=<LT> | op=<GE> | op=<LE> ) 
      prox = ExpressaoAditiva() 
      {
          No novoPai = new No("Op.Relacional", op.image);
          novoPai.addFilho(atual);
          novoPai.addFilho(prox);
          atual = novoPai;
      }
    )*
    { return atual; }
}

No ExpressaoAditiva() : { No atual, prox; Token op; } 
{
    atual = ExpressaoMultiplicativa() 
    ( 
      ( op=<PLUS> | op=<MINUS> ) 
      prox = ExpressaoMultiplicativa() 
      {
          No novoPai = new No("Op.Aditivo", op.image);
          novoPai.addFilho(atual);
          novoPai.addFilho(prox);
          atual = novoPai;
      }
    )*
    { return atual; }
}

No ExpressaoMultiplicativa() : { No atual, prox; Token op; } 
{
    atual = Termo() 
    ( 
      ( op=<MULT> | op=<DIV> | op=<DIVINT> | op=<MOD> | op=<POW> ) 
      prox = Termo() 
      {
          No novoPai = new No("Op.Multiplicativo", op.image);
          novoPai.addFilho(atual);
          novoPai.addFilho(prox);
          atual = novoPai;
      }
    )*
    { return atual; }
}

No Termo() : { Token t; No n; }
{
    t=<IDENTIFIER>     { return new No("Var", t.image); }
  | t=<NUMBER>         { return new No("Num", t.image); }
  | t=<STRING_LITERAL> { return new No("String", t.image); }
  | <LPAREN> n=Expressao() <RPAREN> { return n; }
}