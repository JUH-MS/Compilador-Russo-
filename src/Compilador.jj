options {
  STATIC = false;
}

PARSER_BEGIN(RusskiyCompiler)
import java.io.*;
import java.util.HashSet;
import java.util.Set;

public class RusskiyCompiler {
    // TABELA DE SÍMBOLOS: Guarda os nomes das variáveis declaradas
    private Set<String> tabelaSimbolos = new HashSet<String>();

    public static void main(String args[]) throws ParseException {
      RusskiyCompiler parser = new RusskiyCompiler(System.in);
      while (true) {
        System.out.println("------------------------------------------------");
        System.out.println("Nachalo - Compilador Russo (Digite ou CTRL+C para sair):");
        System.out.print("> ");
        try {
            parser.Programa(); 
            System.out.println("Codigo aceito!");
        } catch (ParseException e) {
            System.out.println("Erro: " + e.getMessage());
            parser.ReInit(System.in);
        } catch (TokenMgrError e) {
            System.out.println("Erro Lexico: " + e.getMessage());
            parser.ReInit(System.in);
        }
      }
    }
}
PARSER_END(RusskiyCompiler)

// ==========================================
// CÓDIGO DE RECUPERAÇÃO DE ERRO (JAVACODE)
// ==========================================
JAVACODE
void error_skipto(int kind) {
  ParseException e = generateParseException();
  System.out.println(e.getMessage());
  Token t;
  do { t = getNextToken(); } while (t.kind != kind && t.kind != EOF);
}

// -----------------------------------------
// MÉTODO DE SINCRONIZAÇÃO GLOBAL (PANIC MODE)
// -----------------------------------------
void error_skipto(int... tokens) {
    try {
        Token t = getToken(1);
        while (true) {
            for (int k : tokens) {
                if (t.kind == k) return;
            }
            t = getNextToken();
        }
    } catch (Throwable e) {
        return; // chegou ao EOF
    }
}

// ==========================================
// TOKENS (Palavras Reservadas em Russo)
// ==========================================

SKIP : { " " | "\t" | "\n" | "\r" | "\u00a0" }


MORE : { "ili" : IN_SINGLE_LINE_COMMENT }
<IN_SINGLE_LINE_COMMENT> SKIP : { < ~["\n","\r"] > }
<IN_SINGLE_LINE_COMMENT> SKIP : { < ("\n"|"\r"|"\r\n") > : DEFAULT }

TOKEN : {
    < VOID      : "pusto"                                                      > 
  | < INT       : "tseloye"                                                    > 
  | < FLOAT     : "drobnoye"                                                   > 
  | < STRING    : "slova"                                                      >

    // Estruturas de Controle
  | < IF        : "yesli"                                                      > 
  | < ELSE      : "inache"                                                     > 
  | < FOR       : "kazhday"                                                    > 
  | < WHILE     : "poka"                                                       >

    // Entrada e Saída
  | < PRINT     : "vyvod"                                                      > 
  | < INPUT     : "vvod"                                                       >

    // Operadores
  | < EQ        : "=="                                                         > 
  | < NEQ       : "!="                                                         > 
  | < LE        : "<="                                                         > 
  | < GE        : ">="                                                         >
  | < INC       : "++"                                                         > 
  | < DEC       : "--"                                                         > 
  | < POW       : "**"                                                         > 
  | < DIVINT    : "//"                                                         >
  | < ASSIGN    : "="                                                          > 
  | < GT        : ">"                                                          > 
  | < LT        : "<"                                                          >
  | < PLUS      : "+"                                                          > 
  | < MINUS     : "-"                                                          > 
  | < MULT      : "*"                                                          > 
  | < DIV       : "/"                                                          > 
  | < MOD       : "%"                                                          >

    // Pontuação
  | < LPAREN    : "("                                                          > 
  | < RPAREN    : ")"                                                          > 
  | < LBRACE    : "{"                                                          > 
  | < RBRACE    : "}"                                                          >
  | < SEMICOLON : ";"                                                          > 
  | < COMMA     : ","                                                          > 
  | < DOT       : "."                                                          >

    // Literais (Números e Identificadores)
  | < NUMBER: (["0"-"9"])+ ( "." (["0"-"9"])+ )?                               >
  | < STRING_LITERAL: "\"" (~["\"","\n","\r"])* "\""                           >
  | < IDENTIFIER: ["a"-"z","A"-"Z","_"] ( ["a"-"z","A"-"Z","0"-"9","_"] )*     >
}

// ==========================================
// GRAMÁTICA (LL1 + AST + Semântica)
// ==========================================

No Programa() : { 
    No raiz = new No("PROGRAMA"); 
    No filho; 
}
{
    { tabelaSimbolos.clear(); }

    (
        try {
            filho = Comando()
            { if (filho != null) raiz.addFilho(filho); }
        } catch (ParseException e) {
            error_skipto(SEMICOLON, RBRACE);
            raiz.addFilho(new No("[ERRO]"));
        }
    )*
    <EOF>
    {
        raiz.imprimirRaiz();
        return raiz;
    }
}

No Comando() : { No n = null; }
{
    try {
        (
            n = Condicional()
          | n = Iteracao()
          | n = IO()
          | n = Declaracao()
          | n = FraseFinalizada()
        )
        { return n; }
    } catch (ParseException e) {
        error_skipto(SEMICOLON, RBRACE);
        return new No("[ERRO]");
    }
}

No IO() : { No n = new No("IO"); No expr; Token t; }
{
    try {

        <PRINT> <LPAREN> expr = Expressao() <RPAREN> <SEMICOLON>
        { n.addFilho(new No("Comando","vyvod")); n.addFilho(expr); return n; }

      |
        <INPUT> <LPAREN> t=<IDENTIFIER> <RPAREN> <SEMICOLON>
        {
            if (!tabelaSimbolos.contains(t.image)) {
                throw new ParseException("Variável '" + t.image + "' não declarada.");
            }
            n.addFilho(new No("Comando","vvod"));
            n.addFilho(new No("Var", t.image));
            return n;
        }

    } catch (ParseException e) {
        error_skipto(SEMICOLON);
        return new No("[ERRO]");
    }
}

No FraseFinalizada() : { No n = null; }
{
    try {
        n = Frase() <SEMICOLON> { return n; }
    } catch (ParseException e) {
        error_skipto(SEMICOLON);
        return new No("[ERRO]"); 
    }
}

No Frase() : { No expr; No n = new No("Frase"); No atrib; }
{
    expr = Expressao() 
    (
        <ASSIGN> atrib = Expressao()
        { n = new No("Atribuicao"); n.addFilho(expr); n.addFilho(new No("Operador", "=")); n.addFilho(atrib); return n; }
      | <INC>
        { n = new No("Incremento"); n.addFilho(expr); return n; }
      | <DEC>
        { n = new No("Decremento"); n.addFilho(expr); return n; }
    )?
    { return expr; }
}

No Declaracao() : { No n = new No("Declaracao"); No tipo; Token t; No inic = null; }
{
    try {
        tipo = TipoEspecificador() t=<IDENTIFIER>
        {
            if (tabelaSimbolos.contains(t.image)) {
                throw new ParseException("Variável '" + t.image + "' já existe.");
            }
            tabelaSimbolos.add(t.image);
        }

        inic = OpcionalInicializacao()
        <SEMICOLON>
        {
            n.addFilho(tipo);
            n.addFilho(new No("Var", t.image));
            if (inic != null) { n.addFilho(new No("Inicializacao")); n.addFilho(inic); }
            return n;
        }

    } catch (ParseException e) {
        error_skipto(SEMICOLON);
        return new No("[ERRO]");
    }
}

No OpcionalInicializacao() : { No expr = null; }
{
    [ <ASSIGN> expr = Expressao() ] { return expr; }
}

No TipoEspecificador() : { Token t; }
{
    ( t=<VOID> | t=<INT> | t=<FLOAT> | t=<STRING> )
    { return new No("Tipo", t.image); }
}

No Condicional() :
{ 
    No n = new No("IF"); 
    No cond; 
    No cmd; 
    No blocoIf = new No("Bloco True"); 
    No blocoElse = null; 
}
{
    try {
        <IF> <LPAREN> cond=Expressao() <RPAREN> <LBRACE>
        { n.addFilho(cond); }

        (
            try {
                cmd = Comando() { blocoIf.addFilho(cmd); }
            } catch (ParseException e) {
                error_skipto(RBRACE);
                blocoIf.addFilho(new No("[ERRO]"));
            }
        )*

        <RBRACE>
        { n.addFilho(blocoIf); }

        [
            <ELSE> <LBRACE> { blocoElse = new No("Bloco Else"); }
            (
                try {
                    cmd = Comando() { blocoElse.addFilho(cmd); }
                } catch (ParseException e) {
                    error_skipto(RBRACE);
                    blocoElse.addFilho(new No("[ERRO]"));
                }
            )*
            <RBRACE> { n.addFilho(blocoElse); }
        ]

        { return n; }

    } catch (ParseException e) {
        error_skipto(RBRACE, SEMICOLON);
        return new No("[ERRO]");
    }
}

No Iteracao() :
{ 
    No n = new No("WHILE"); 
    No cond; 
    No cmd; 
    No bloco = new No("Bloco Loop"); 
}
{
    try {
        <WHILE> <LPAREN> cond=Expressao() <RPAREN> <LBRACE>
        { n.addFilho(cond); }

        (
            try {
                cmd = Comando() { bloco.addFilho(cmd); }
            } catch (ParseException e) {
                error_skipto(RBRACE);
                bloco.addFilho(new No("[ERRO]"));
            }
        )*

        <RBRACE>
        { n.addFilho(bloco); return n; }

    } catch (ParseException e) {
        error_skipto(RBRACE, SEMICOLON);
        return new No("[ERRO]");
    }
}

No Expressao() : { No n; } { n = ExpressaoRelacional() { return n; } }

No ExpressaoRelacional() : { No atual, prox; Token op; }
{
    atual = ExpressaoAditiva() 
    ( ( op=<EQ> | op=<NEQ> | op=<GT> | op=<LT> | op=<GE> | op=<LE> ) prox = ExpressaoAditiva() 
      { No novoPai = new No("Op.Relacional", op.image); novoPai.addFilho(atual); novoPai.addFilho(prox); atual = novoPai; }
    )* { return atual; }
}

No ExpressaoAditiva() : { No atual, prox; Token op; } 
{
    atual = ExpressaoMultiplicativa() 
    ( ( op=<PLUS> | op=<MINUS> ) prox = ExpressaoMultiplicativa() 
      { No novoPai = new No("Op.Aditivo", op.image); novoPai.addFilho(atual); novoPai.addFilho(prox); atual = novoPai; }
    )* { return atual; }
}

No ExpressaoMultiplicativa() : { No atual, prox; Token op; } 
{
    atual = Termo() 
    ( ( op=<MULT> | op=<DIV> | op=<DIVINT> | op=<MOD> | op=<POW> ) prox = Termo() 
      { No novoPai = new No("Op.Multiplicativo", op.image); novoPai.addFilho(atual); novoPai.addFilho(prox); atual = novoPai; }
    )* { return atual; }
}

No Termo() : { Token t; No n; }
{
    try {

        t=<IDENTIFIER>
        {
            if (!tabelaSimbolos.contains(t.image)) {
                throw new ParseException("Variável '" + t.image + "' não declarada.");
            }
            return new No("Var", t.image);
        }
    |
        t=<NUMBER> { return new No("Num", t.image); }
    |
        t=<STRING_LITERAL> { return new No("String", t.image); }
    |
        <LPAREN> n=Expressao() <RPAREN> { return n; }

    } catch (ParseException e) {
        error_skipto(RPAREN, SEMICOLON);
        return new No("[ERRO]");
    }
}